{ pkgs
, src
, crate
}:
let
  # TODO: automatically copy over all symlinks as necessary
  # instead of doing it manually here
  dir = import ../tree.nix { inherit pkgs; path = src; };
  cxxh = builtins.toFile "cxx.h" (builtins.readFile dir.include.rust."cxx.h");
  buildCommand = ''
  # Copy over the sources generated by cxx
  mkdir $out
  cp -r ${src}/sources $out/sources

  # Copy over the include headers generated
  mkdir -p $out/include

  # copy over rust/cxx.h
  # TODO: automatically copy over all symlinks as necessary
  mkdir -p $out/include/rust
  cp ${cxxh} $out/include/rust/cxx.h

  ## we move to src so that find returns path relative to it
  ## otherwise it'd return absolute paths
  cd ${src}
  for HEADER in `find ./include -name "*.h" -type f`; do
      ## make sure the folder exists
      mkdir -p $out/$(dirname $HEADER)

      ## we copy with --parents to keep the structure
      ## and since we are copying from the store
      ## we'd be copying with root permissions (so we can't write it!)
      cp --parents --no-preserve=ownership $HEADER $out/
  done
  # (restore folder before our cd to src)
  cd ..

  ## and create the .rs links that would normally be there
  ## but we need to have them pointing at the store instead
  INCLUDES=`find $out/include -name "*.h" -type f`
  for INC in $INCLUDES; do
    ln -s ./$(basename $INC) ''${INC%.*}
  done

  # Recreate crate link (to point to the store)
  # which is expected in to be used in the include paths
  mkdir -p $out/crate
  ln -s ${crate.src} $out/crate/${crate.pname}
'';
in
pkgs.stdenv.mkDerivation {
  name = "${crate.pname}-${crate.version}-cxxbridge";
  inherit src buildCommand;

  buildInputs = [ crate.src ];
}
